{0 [getting] : HTTP Loading for the {{:https://github.com/edchapman88/r3ace}{b R{^ 3}ACE}} Project}


Dispatch {e timely} HTTP loads. [getting] uses two system threads to:
+ Synchronously dispatch requests at time intervals that follow a specifies distribution, immediately handing off the pending (promised) responses to the other thread (via a "single-producer, single-consumer (SPSC) channel).
+ An asynchronous runtime, reading promised HTTP responses from the SPSC channel and chasing the collection of promises to fulfillment.

Part of the {{:https://github.com/edchapman88/r3ace}{b R{^ 3}ACE}} project: {e Replicable} and {e Reproducible} {e Real-World} Autonomous Cyber Environments, [getting] is used to apply an HTTP load to a web server and broadcast a stream of signals to a system interface (either Serial or UDP), indicating when OK (status code = 200) responses have been received from the web server.

{1 Installation}
This project depends on [Lwt], which is a library to handle I/O operations with asynchronous promises. [Lwt] has two backend implementations, [libev] and [select]. [select] is limited to supporting only 1024 file descriptors which is a problem for high throughput servers or clients. With a high load, a [Unix.EINVAL] exception is raised, referencing [Unix.select] as the function responsible for the failure.

{2 Installing and enbaling [libev]}
As described in the 'Lwt scheduler' section of the {{:https://ocsigen.org/lwt/latest/manual/manual}Lwt manual}, there are two prerequisites to meet such that [Lwt] will compile with the non-default (but more performant) [libev] backend:
+ Install [libev] on your system with one of:
    - [brew install libev]
    - [apt-get install libev-dev]
    - The NixPkg {{:https://github.com/NixOS/nixpkgs/tree/nixos-24.05/pkgs/development/libraries/libev}[libev]}
+ Install [getting], e.g. in a new opam switch with
{[
opam switch create .
}]
Note, opam will request the installation of an external dependency [pkgconf] if this is not already installed, go ahead with the installation.

{2 Troubleshooting}
- The installation fails while compiling [conf-pkg-config]. This is likely due to recent change in the name of the [pkgconf] dependency (e.g. you already had [pkg-config] installed with brew). If using brew, [brew uninstall pkgconf pkg-config]. Then re-install [getting] and accept the request from opam to install external dependencies with brew.
You can test the newly compiled [Lwt] with:
{[
let () =
  let open Lwt_sys in
  print_endline (string_of_bool (have `libev))
]}

If this returns false, [Lwt] may not have recognised [libev]. Try setting the following environment variables and then re-installing [Lwt]:
{[
export C_INCLUDE_PATH=<path to where libev installed>
export LIBRARY_PATH=<path to where libev installed>
]}

E.g. for [brew] installed [libev] the path would be something like [/opt/homebrew/Cellar]

{1 High server or client loads}
If serving or sending a high volume of requests there are two errors that are likely to occur. The first is discussed above, and is address by ensuring the [libev] backend is being used by [Lwt]. The second is due to the configuration of the file descriptor limit set for the linux user executing the program. Running [ulimit -a] in a shell will show all of the limits for that user. [ulimit -n] shows only the file descriptors limit of interest. The limit can be set high with [ulimit -n 20000].

The exception caused by a high load when the file descriptor limit is too low is of type [Unix.ENFILE], for 'Too many open files in the system'.

The full set of [Unix] exception types can be found {{:https://ocaml.org/manual/5.2/api/Unix.html}here}.

{1 Microprobe}
This repository contains a helper tool to be used as a system probe: parsing and analysing the serial output from the web client in real-time on a microcontroller. The tool is designed specifically for the {{:https://microbit.org/}BBC microbit}, but the source code could be used as inspiration for alternatives.

{2 Usage}
1. Plug the microbit in to a USB port, it will by recognised as a USB storage device.
2. Flash the [.hex] file onto a microbit by copying the file onto the device.
3. Plug the microbit into the device running the web client.
4. Establish the file system path to the microbit device (e.g. [ls /dev/tty.*] or [ls /dev/cu.*]).
5. Pass the file system path to the web client CLI (e.g. with [-p /dev/tty.ACM0]).
6. The microbit LED display is used to show whether [0]s or [1]s are emitted by the web client on the serial port ([0], request failed, LED off; [1], request succeeded, LED on).
7. It takes some time (around 10s to 3 minutes depending on the configuration of the probe and the web client request rate) to fill up the evaluation buffer on the microbit, after which there will be a high pitched buzz.
7. Thereafter, if {e either}:
    - the proportion of requests that are successful is < some constant [gamma]
    {e or}:
    - the rate of successful requests is < some constant rate [lambda] 
    then a lower pitched buzzer will sound on the microbit.
8. [gamma] and [lambda] are configured in the source code for the tool, discussed below.

{2 Configuration and Compiling}
[./microprobe.js] is source code that is compiled to the [./microbit_show_serial.hex] file. The source code depends on libraries made available by Microsoft. It is most easily compiling by pasting the code into a new project on the Microsoft Makecode website, {{:https://makecode.microbit.org/}makecode.microbit.org}, after which a [.hex] file can be downloaded or flashed directly onto a microbit that is plugged in.

{2 Example Scenario}
- Web server successfully responding to 80% of the incoming requests, on average.
- Probe configured with [gamma = 0.9] and [lambda = 10].

Two possible scenarios:
+ {b Low Load - judged against the [gamma] criteria}
    - Web client making 5 Queries Per Second (QPS).
    - It takes two minutes to initialise the probe.
    - Neither criteria are met, so the buzzer is on.
    - If the server would instead have to correctly respond to 95% of incoming requests to satisfy the [gamma] criteria and the buzzer would not sound.
+ {b High Load - judged against the [lambda] criteria}
    - Web client making 20 Queries Per Second (QPS).
    - It takes 30 seconds to initialise the probe.
    - The [lambda] criteria is met, so the buzzer does not sound.
    - On average the server responds correctly at a rate of 16 Responses Per Second (RPS) (0.8 * 20), and this is above the [lambda] criteria of 10 (RPS).
    - Even if the server only responds to just over 50% of the requests in this high load scenario, the [lambda] criteria is met.

{1 TLS and Sources for X509 Certificates}
The [ca-certs] package is responsible for TLS authentication. {{:https://ocaml.org/p/ca-certs/latest/doc/Ca_certs/index.html#val-trust_anchors}[trust_anchors()]} "detects the root CAs (trust anchors) in the operating system's trust store". In the case of MacOS, {b only the CAs in the 'system roots' keychain are picked up}. This prohibits using the 'login' keychain to add custom CAs to the set of CAs trusted by [ca-certs]. There is an open {{:https://github.com/mirage/ca-certs/pull/28}PR} addressing this issue. Until merged, the work around is to point the [SSL_CERT_FILE] to a .pem file (a copy of the file that probably already exists at [/etc/ssl/cert.pem]) that includes the addition custom CAs. E.g. in [~/.zshrc], [export SSL_CERT_FILE=/etc/ssl/cert_extended.pem].

